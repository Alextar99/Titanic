# ==============================================================
# ANÁLISIS EXPLORATORIO: House Prices – Advanced Regression
# Kaggle: house-prices-advanced-regression-techniques
# URL   : https://www.kaggle.com/competitions/
#         house-prices-advanced-regression-techniques
# ==============================================================


# ==============================================================
# 0. INSTALACIÓN Y CARGA DE LIBRERÍAS
# ==============================================================

rm(list = ls())
dev.off()

pkgs <- c(
  "tidyverse", "skimr",    "naniar",   "corrplot",
  "plotly",    "scales",   "gridExtra","moments",
  "ggridges",  "viridis",  "ggrepel"
)
for (p in pkgs) {
  if (!requireNamespace(p, quietly = TRUE)) install.packages(p)
}

library(tidyverse)
library(skimr)
library(naniar)
library(corrplot)
library(plotly)
library(scales)
library(gridExtra)
library(moments)
library(ggridges)
library(viridis)
library(ggrepel)

# Tema gráfico personalizado
theme_hp <- theme_minimal(base_size = 11) +
  theme(
    plot.title    = element_text(face = "bold", size = 13, hjust = 0),
    plot.subtitle = element_text(color = "grey40", size = 10),
    axis.title    = element_text(size = 10),
    legend.title  = element_text(face = "bold", size = 9),
    strip.text    = element_text(face = "bold")
  )


# ==============================================================
# a) PREPARACIÓN DE LOS DATOS
# ==============================================================

# --------------------------------------------------------------
# a.1) DESCRIPCIÓN DEL CONJUNTO ORIGINAL
# --------------------------------------------------------------
cat(strrep("=", 65), "\n")
cat("NOMBRE   : House Prices – Advanced Regression Techniques\n")
cat("FUENTE   : Kaggle\n")
cat("ENLACE   : https://www.kaggle.com/competitions/\n")
cat("           house-prices-advanced-regression-techniques\n")
cat("CONTEXTO : Precios de venta de viviendas residenciales\n")
cat("           en Ames, Iowa (EE.UU.) — años 2006-2010\n")
cat(strrep("=", 65), "\n\n")

# !! Ajusta la ruta a la ubicación de tu archivo train.csv !!
train_raw <- read.csv("train.csv", header = TRUE, stringsAsFactors = FALSE)

n_obs  <- nrow(train_raw)
n_vars <- ncol(train_raw)
n_num  <- sum(sapply(train_raw, is.numeric))
n_chr  <- sum(sapply(train_raw, is.character))

cat(sprintf("Número de individuos (filas)     : %d\n",   n_obs))
cat(sprintf("Número de variables (columnas)   : %d\n",   n_vars))
cat(sprintf("  - Variables numéricas          : %d\n",   n_num))
cat(sprintf("  - Variables de texto (categ.)  : %d\n\n", n_chr))

cat("Variables del dataset:\n")
print(names(train_raw))

cat("\nPrimeras 5 filas (primeras 10 columnas):\n")
print(head(train_raw[, 1:10], 5))


# --------------------------------------------------------------
# a.2) TRANSFORMACIÓN, LIMPIEZA E IMPUTACIÓN
# --------------------------------------------------------------
train <- train_raw  # copia de trabajo: train_raw queda intacto

# Renombrar variables con nombres no sintácticos en R
# (nombres que empiezan por número causan problemas en tidyverse)
train <- train %>%
  rename(FlrSF_1st  = X1stFlrSF,
         FlrSF_2nd  = X2ndFlrSF,
         Porch_3Ssn = X3SsnPorch)


# --- PASO 1: Diagnóstico de valores perdidos ------------------
miss_df <- data.frame(
  Variable    = names(train),
  N_Missing   = colSums(is.na(train)),
  Pct_Missing = round(100 * colMeans(is.na(train)), 2)
) %>%
  filter(N_Missing > 0) %>%
  arrange(desc(Pct_Missing))

cat("\n--- Diagnóstico de valores perdidos (antes de imputar) ---\n")
print(miss_df, row.names = FALSE)

# Visualización: gráfico de barras por % de NAs por variable
p_miss <- gg_miss_var(train, show_pct = TRUE) +
  labs(
    title    = "Porcentaje de valores faltantes por variable",
    subtitle = sprintf("House Prices — Kaggle  (n = %d obs., %d vars.)",
                       n_obs, n_vars),
    y = "% Missing"
  ) + theme_hp
print(p_miss)


# --- PASO 2: Imputación semántica (según data dictionary) -----

# 2a. Categóricas: NA = "No tiene esa característica"
#     Fuente: data_description.txt de Kaggle — indica explícitamente
#     que NA significa ausencia de la característica (sin sótano,
#     sin garaje, sin piscina, etc.), no un dato perdido.
na_none_cat <- c(
  "Alley",        "MasVnrType",   "BsmtQual",    "BsmtCond",
  "BsmtExposure", "BsmtFinType1", "BsmtFinType2","FireplaceQu",
  "GarageType",   "GarageFinish", "GarageQual",  "GarageCond",
  "PoolQC",       "Fence",        "MiscFeature"
)
for (v in na_none_cat) {
  train[[v]][is.na(train[[v]])] <- "None"
}

# 2b. Numéricas: NA = 0 (la casa no tiene esa característica,
#     por tanto su área o capacidad es literalmente cero)
na_zero_num <- c(
  "MasVnrArea", "BsmtFinSF1",   "BsmtFinSF2",  "BsmtUnfSF",
  "TotalBsmtSF","BsmtFullBath", "BsmtHalfBath",
  "GarageCars", "GarageArea",   "GarageYrBlt"
)
for (v in na_zero_num) {
  train[[v]][is.na(train[[v]])] <- 0
}

# 2c. LotFrontage (~18% NA): dato realmente perdido (la casa sí
#     tiene fachada pero no se midió). Se imputa con la mediana
#     del propio barrio: parcelas del mismo Neighborhood tienden
#     a ser similares → estimación más precisa que la media global.
train <- train %>%
  group_by(Neighborhood) %>%
  mutate(LotFrontage = if_else(
    is.na(LotFrontage),
    median(LotFrontage, na.rm = TRUE),
    as.double(LotFrontage)
  )) %>%
  ungroup()

# 2d. Electrical (1 NA): se imputa con la moda (valor más frecuente).
#     Con un solo NA el impacto es mínimo; la moda es la mejor
#     estimación para una variable categórica.
moda_elec <- names(which.max(table(train$Electrical)))
train$Electrical[is.na(train$Electrical)] <- moda_elec


# --- PASO 3: Feature Engineering ------------------------------
# Se extraen las nuevas variables ANTES de convertir YrSold a factor,
# porque las operaciones aritméticas requieren valores numéricos.
yr_num <- as.integer(as.character(train$YrSold))

train <- train %>%
  mutate(
    # Antigüedad de la vivienda en el momento de la venta
    HouseAge     = yr_num - YearBuilt,
    # Años desde la última remodelación
    RemodAge     = yr_num - YearRemodAdd,
    # Superficie total: sótano + planta baja + planta alta
    TotalSF      = TotalBsmtSF + FlrSF_1st + FlrSF_2nd,
    # Baños totales: completos cuentan 1, medios baños 0.5
    # (convención estándar del sector inmobiliario)
    TotalBaths   = FullBath + 0.5 * HalfBath +
                   BsmtFullBath + 0.5 * BsmtHalfBath,
    # Variables indicadoras: presencia de la característica
    HasPool      = factor(ifelse(PoolArea    > 0, "Sí", "No")),
    HasGarage    = factor(ifelse(GarageArea  > 0, "Sí", "No")),
    HasFireplace = factor(ifelse(Fireplaces  > 0, "Sí", "No")),
    HasBasement  = factor(ifelse(TotalBsmtSF > 0, "Sí", "No")),
    # Transformación logarítmica de la variable respuesta
    # (normaliza la distribución sesgada de SalePrice)
    logSalePrice = log(SalePrice)
  ) %>%
  mutate(
    # "Feature reina": calidad general × superficie total
    # Captura simultáneamente tamaño Y calidad → correlación ~0.88
    QualSF       = as.integer(OverallQual) * TotalSF,
    # Superficie total de porches
    TotalPorchSF = OpenPorchSF + EnclosedPorch + Porch_3Ssn + ScreenPorch
  )

# Verificar correlación de las nuevas variables con SalePrice
new_feats <- c("QualSF", "TotalSF", "TotalBaths",
               "TotalPorchSF", "HouseAge", "RemodAge", "SalePrice")
cor_new <- cor(
  train %>% select(all_of(new_feats)),
  use = "pairwise.complete.obs"
)["SalePrice", ] %>% sort(decreasing = TRUE)

cat("\nCorrelación de las variables derivadas con SalePrice:\n")
print(round(cor_new, 3))


# --- PASO 4: Conversión al tipo de dato correcto --------------

# MSSubClass: código numérico que representa tipo de vivienda,
# no una magnitud → factor nominal
train$MSSubClass <- factor(train$MSSubClass)

# OverallQual / OverallCond: escala 1–10 con orden real → ordinal
train$OverallQual <- factor(train$OverallQual, levels = 1:10, ordered = TRUE)
train$OverallCond <- factor(train$OverallCond, levels = 1:10, ordered = TRUE)

# MoSold: número del mes → factor con etiquetas legibles
train$MoSold <- factor(train$MoSold, levels = 1:12, labels = month.abb)

# YrSold: año de venta → factor nominal
train$YrSold <- factor(train$YrSold)

# Variables de calidad con escala estandarizada Po→Ex
# "None" se incluye como primer nivel (casas sin esa característica)
quality_levels <- c("None", "Po", "Fa", "TA", "Gd", "Ex")
ord_qual_vars  <- c(
  "ExterQual", "ExterCond",  "BsmtQual",   "BsmtCond",
  "HeatingQC", "KitchenQual","FireplaceQu",
  "GarageQual","GarageCond"
)
for (v in ord_qual_vars) {
  train[[v]] <- factor(train[[v]], levels = quality_levels, ordered = TRUE)
}

# Resto de variables de texto → factor nominal
chr_vars <- names(train)[sapply(train, is.character)]
train[chr_vars] <- lapply(train[chr_vars], factor)


# --- PASO 5: Verificación final de valores perdidos -----------
n_na_restantes <- sum(is.na(train))
cat(sprintf("\nValores perdidos tras la imputación: %d\n", n_na_restantes))
if (n_na_restantes > 0) {
  cat("Variables con NAs restantes:\n")
  print(names(which(colSums(is.na(train)) > 0)))
}


# --------------------------------------------------------------
# a.3) RESUMEN FINAL DEL CONJUNTO
# --------------------------------------------------------------
cat("\n", strrep("=", 65), "\n")
cat("RESUMEN FINAL (TRAS PREPROCESADO)\n")
cat(strrep("=", 65), "\n")
cat(sprintf("Individuos                : %d\n",  nrow(train)))
cat(sprintf("Variables totales         : %d\n",  ncol(train)))
cat(sprintf("  - Numéricas             : %d\n",  sum(sapply(train, is.numeric))))
cat(sprintf("  - Factor / Ordinal      : %d\n",  sum(sapply(train, is.factor))))
cat(sprintf("  - Valores perdidos      : %d\n\n",sum(is.na(train))))

print(skim(train))


# ==============================================================
# a.4) TRATAMIENTO DE OUTLIERS
# ==============================================================
# Referencia metodológica: Tukey (1977) — método IQR clásico.
#
# Un dato atípico NO es necesariamente un error: puede representar
# una observación real y legítima en un extremo de la distribución.
# La decisión de tratarlos es ESTADÍSTICA, no automática.
#
# Metodología aplicada:
#   PASO 6  — Diagnóstico univariante: Tukey 1.5·IQR
#   PASO 7  — Visualización: mosaico de boxplots
#   PASO 8  — Análisis contextual: ¿son errores o casos reales?
#   PASO 9  — Decisión y winsorización conservadora [P1%, P99%]
#   PASO 10 — Verificación visual pre/post
# ==============================================================

out_vars <- c(
  "SalePrice",  "GrLivArea",  "LotArea",    "LotFrontage",
  "TotalSF",    "TotalBsmtSF","GarageArea", "TotalBaths",
  "HouseAge",   "QualSF"
)

# --- PASO 6: Diagnóstico Tukey 1.5·IQR -----------------------
diag_out <- do.call(rbind, lapply(out_vars, function(v) {
  x   <- train[[v]]
  q1  <- quantile(x, 0.25, na.rm = TRUE)
  q3  <- quantile(x, 0.75, na.rm = TRUE)
  iqr <- q3 - q1
  n_out <- sum(x < q1 - 1.5*iqr | x > q3 + 1.5*iqr, na.rm = TRUE)
  data.frame(
    Variable  = v,
    N_out     = n_out,
    Pct_out   = round(100 * n_out / sum(!is.na(x)), 1),
    Asimetria = round(moments::skewness(x, na.rm = TRUE), 2)
  )
})) %>% arrange(desc(Pct_out))

cat("\n", strrep("=", 65), "\n")
cat("PASO 6 — DIAGNÓSTICO DE OUTLIERS (Tukey 1.5·IQR)\n")
cat(strrep("=", 65), "\n")
print(diag_out, row.names = FALSE)


# --- PASO 7: Mosaico de boxplots ------------------------------
plots_box <- lapply(out_vars, function(v) {
  q1  <- quantile(train[[v]], 0.25, na.rm = TRUE)
  q3  <- quantile(train[[v]], 0.75, na.rm = TRUE)
  iqr <- q3 - q1
  n_out <- sum(train[[v]] < q1 - 1.5*iqr | train[[v]] > q3 + 1.5*iqr, na.rm = TRUE)

  ggplot(train, aes(x = factor(1), y = .data[[v]])) +
    geom_boxplot(fill = "#4393C3", alpha = 0.70,
                 outlier.color = "#D7191C",
                 outlier.alpha = 0.55, outlier.size = 1) +
    scale_y_continuous(labels = label_comma()) +
    labs(title    = v,
         subtitle = paste0("Out: ", n_out),
         x = NULL, y = NULL) +
    theme_minimal(base_size = 8) +
    theme(plot.title    = element_text(face = "bold", size = 8),
          plot.subtitle = element_text(size = 7, color = "#D7191C"),
          axis.text.x   = element_blank(),
          axis.ticks.x  = element_blank())
})

do.call(grid.arrange, c(plots_box, list(
  ncol = 5,
  top  = "PASO 7 — Boxplots diagnósticos: outliers Tukey 1.5·IQR en rojo"
)))


# --- PASO 8: Análisis contextual ------------------------------
# GrLivArea: las casas con área habitable extrema y precio bajo
# corresponden a ventas parciales o condiciones atípicas
# (SaleCondition ≠ "Normal"). No son errores de registro.
# → Decisión: no eliminar; tratar con winsorización.

cat("\n--- Casos con GrLivArea extrema ---\n")
lim_grv <- quantile(train$GrLivArea, 0.99)
train %>%
  filter(GrLivArea > lim_grv) %>%
  select(Id, GrLivArea, TotalSF, SalePrice,
         OverallQual, Neighborhood, SaleCondition) %>%
  arrange(desc(GrLivArea)) %>%
  print(n = Inf)


# --- PASO 9: Winsorización conservadora [P1%, P99%] -----------
# La winsorización sustituye los valores extremos por el cuantil
# de corte, conservando TODAS las observaciones (ninguna se elimina).
# Se aplica solo a las variables con mayor asimetría y más outliers.
#
# Variables excluidas:
#   SalePrice   → valores altos son reales; logSalePrice reduce su peso
#   TotalBsmtSF, GarageArea, TotalBaths → colas moderadas y plausibles

winsorize_pct <- function(x, lo = 0.01, hi = 0.99) {
  pmin(pmax(x, quantile(x, lo, na.rm = TRUE)),
              quantile(x, hi, na.rm = TRUE))
}

vars_wins  <- c("LotArea", "LotFrontage", "GrLivArea", "TotalSF", "QualSF")
train_prewin <- train   # copia pre-winsorización para comparación

for (v in vars_wins) train[[v]] <- winsorize_pct(train[[v]])

cat("\n--- Efecto de la winsorización [P1%, P99%] ---\n")
comp_wins <- do.call(rbind, lapply(vars_wins, function(v) {
  data.frame(
    Variable     = v,
    Max_antes    = round(max(train_prewin[[v]], na.rm = TRUE)),
    Max_despues  = round(max(train[[v]],        na.rm = TRUE)),
    Asim_antes   = round(moments::skewness(train_prewin[[v]], na.rm = TRUE), 2),
    Asim_despues = round(moments::skewness(train[[v]],        na.rm = TRUE), 2)
  )
}))
print(comp_wins, row.names = FALSE)
cat(sprintf("\nObservaciones conservadas: %d (ninguna eliminada)\n", nrow(train)))


# --- PASO 10: Verificación visual pre/post --------------------
plots_pp <- lapply(vars_wins, function(v) {
  df_pp <- data.frame(
    Valor = c(train_prewin[[v]], train[[v]]),
    Fase  = rep(c("Antes", "Después"), each = nrow(train))
  ) %>% filter(is.finite(Valor))

  ggplot(df_pp, aes(x = Fase, y = Valor, fill = Fase)) +
    geom_boxplot(outlier.alpha = 0.4, outlier.size = 0.8,
                 alpha = 0.8, width = 0.5) +
    scale_fill_manual(values = c("Antes" = "#FC8D59", "Después" = "#74ADD1")) +
    scale_y_continuous(labels = label_comma()) +
    labs(title = v, x = NULL, y = NULL) +
    theme_minimal(base_size = 8) +
    theme(plot.title = element_text(face = "bold", size = 9),
          legend.position = "none")
})

do.call(grid.arrange, c(plots_pp, list(
  ncol = 5,
  top  = "PASO 10 — Winsorización [P1%, P99%]: boxplots antes/después"
)))


# ==============================================================
# b) ANÁLISIS EXPLORATORIO DE DATOS (EDA)
# ==============================================================

# ==============================================================
# b.1) ESTUDIO DESCRIPTIVO
# ==============================================================

# ------------------------------------------------------------------
# BLOQUE 1 — Distribución de la variable respuesta: SalePrice
# ------------------------------------------------------------------
p_sp1 <- ggplot(train, aes(x = SalePrice)) +
  geom_histogram(aes(y = after_stat(density)), bins = 50,
                 fill = "#2C7BB6", alpha = 0.75, color = "white") +
  geom_density(color = "#D7191C", linewidth = 1.1) +
  scale_x_continuous(labels = label_dollar()) +
  labs(
    title    = "Distribución de SalePrice (precio de venta)",
    subtitle = sprintf("n = %d  |  Media = %s  |  Mediana = %s  |  Asimetría = %.2f  |  Curtosis = %.2f",
                       nrow(train),
                       dollar(round(mean(train$SalePrice))),
                       dollar(median(train$SalePrice)),
                       skewness(train$SalePrice),
                       kurtosis(train$SalePrice)),
    x = "Precio de venta (USD)", y = "Densidad"
  ) + theme_hp

p_sp2 <- ggplot(train, aes(x = logSalePrice)) +
  geom_histogram(aes(y = after_stat(density)), bins = 50,
                 fill = "#1A9641", alpha = 0.75, color = "white") +
  geom_density(color = "#D7191C", linewidth = 1.1) +
  labs(
    title    = "Distribución de log(SalePrice)",
    subtitle = sprintf("La transformación logarítmica normaliza la distribución  |  Asimetría = %.2f  |  Curtosis = %.2f",
                       skewness(train$logSalePrice),
                       kurtosis(train$logSalePrice)),
    x = "log(Precio de venta)", y = "Densidad"
  ) + theme_hp

grid.arrange(p_sp1, p_sp2, ncol = 2,
             top = "Variable respuesta: SalePrice y su transformación logarítmica")


# ------------------------------------------------------------------
# BLOQUE 2 — Tabla de estadísticos descriptivos (vars. numéricas)
# ------------------------------------------------------------------
num_vars_key <- c(
  "SalePrice", "LotArea",    "LotFrontage", "GrLivArea",
  "TotalSF",   "TotalBsmtSF","FlrSF_1st",   "FlrSF_2nd",
  "GarageArea","TotalBaths", "HouseAge",    "RemodAge",
  "Fireplaces","TotRmsAbvGrd","WoodDeckSF", "OpenPorchSF"
)

stats_tbl <- train %>%
  select(all_of(num_vars_key)) %>%
  pivot_longer(everything(), names_to = "Variable", values_to = "Valor") %>%
  group_by(Variable) %>%
  summarise(
    N       = sum(!is.na(Valor)),
    Media   = round(mean(Valor,            na.rm = TRUE), 1),
    Mediana = round(median(Valor,          na.rm = TRUE), 1),
    DT      = round(sd(Valor,             na.rm = TRUE), 1),
    Min     = round(min(Valor,            na.rm = TRUE), 1),
    Q1      = round(quantile(Valor, 0.25, na.rm = TRUE), 1),
    Q3      = round(quantile(Valor, 0.75, na.rm = TRUE), 1),
    Max     = round(max(Valor,            na.rm = TRUE), 1),
    Asim    = round(skewness(Valor,       na.rm = TRUE), 2),
    Kurt    = round(kurtosis(Valor,       na.rm = TRUE), 2),
    .groups = "drop"
  ) %>%
  arrange(desc(abs(Asim)))

cat("\nTabla de estadísticos descriptivos — variables numéricas clave:\n")
print(stats_tbl, n = Inf)


# ------------------------------------------------------------------
# BLOQUE 3 — Histogramas en mosaico (variables numéricas clave)
# ------------------------------------------------------------------
hist_vars <- c(
  "LotArea", "GrLivArea", "TotalBsmtSF", "GarageArea",
  "TotalSF", "TotalBaths","HouseAge",    "LotFrontage"
)

plots_hist <- lapply(hist_vars, function(v) {
  ggplot(train, aes(x = .data[[v]])) +
    geom_histogram(bins = 40, fill = "#4393C3", alpha = 0.85, color = "white") +
    scale_x_continuous(labels = label_comma()) +
    labs(title = v, x = NULL, y = "Frec.") +
    theme_minimal(base_size = 8) +
    theme(plot.title = element_text(face = "bold", size = 9))
})

do.call(grid.arrange, c(plots_hist, ncol = 4,
                        top = "Distribución de variables numéricas clave"))


# ------------------------------------------------------------------
# BLOQUE 4 — Boxplot: SalePrice por calidad general (OverallQual)
# ------------------------------------------------------------------
p_qual <- ggplot(train, aes(x = OverallQual, y = SalePrice, fill = OverallQual)) +
  geom_boxplot(outlier.alpha = 0.35, outlier.size = 0.8) +
  scale_y_continuous(labels = label_dollar()) +
  scale_fill_viridis_d(option = "plasma") +
  labs(
    title    = "Precio de venta por Calidad General (OverallQual)",
    subtitle = "Escala ordinal: 1 = Muy deficiente → 10 = Excelente",
    x = "Calidad general", y = "Precio de venta (USD)"
  ) +
  theme_hp + theme(legend.position = "none")
print(p_qual)


# ------------------------------------------------------------------
# BLOQUE 5 — Scatterplot: SalePrice vs GrLivArea
# ------------------------------------------------------------------
p_scatter1 <- ggplot(train,
                     aes(x = GrLivArea, y = SalePrice,
                         color = as.numeric(OverallQual))) +
  geom_point(alpha = 0.45, size = 1.5) +
  geom_smooth(method = "lm", color = "black",
              se = TRUE, linewidth = 0.9, linetype = "dashed") +
  scale_y_continuous(labels = label_dollar()) +
  scale_x_continuous(labels = label_comma()) +
  scale_color_viridis_c(option = "plasma", name = "Calidad\nGeneral") +
  labs(
    title    = "SalePrice vs Superficie habitable (GrLivArea)",
    subtitle = sprintf("Correlación de Pearson: r = %.3f",
                       cor(train$SalePrice, train$GrLivArea)),
    x = "Superficie habitable (sq ft)", y = "Precio de venta (USD)"
  ) + theme_hp
print(p_scatter1)


# ------------------------------------------------------------------
# BLOQUE 6 — Scatterplot: SalePrice vs TotalSF (variable creada)
# ------------------------------------------------------------------
p_scatter2 <- ggplot(train,
                     aes(x = TotalSF, y = SalePrice,
                         color = as.numeric(OverallQual))) +
  geom_point(alpha = 0.45, size = 1.5) +
  geom_smooth(method = "lm", color = "black",
              se = TRUE, linewidth = 0.9, linetype = "dashed") +
  scale_y_continuous(labels = label_dollar()) +
  scale_x_continuous(labels = label_comma()) +
  scale_color_viridis_c(option = "plasma", name = "Calidad\nGeneral") +
  labs(
    title    = "SalePrice vs Superficie Total (TotalSF = sótano + P.baja + P.alta)",
    subtitle = sprintf("Correlación de Pearson: r = %.3f",
                       cor(train$SalePrice, train$TotalSF)),
    x = "Superficie total (sq ft)", y = "Precio de venta (USD)"
  ) + theme_hp
print(p_scatter2)


# ------------------------------------------------------------------
# BLOQUE 7 — Precio mediano por Neighborhood (todos los barrios)
# ------------------------------------------------------------------
p_neigh <- train %>%
  group_by(Neighborhood) %>%
  summarise(median_price = median(SalePrice), n = n(), .groups = "drop") %>%
  mutate(Neighborhood = fct_reorder(Neighborhood, median_price)) %>%
  ggplot(aes(x = Neighborhood, y = median_price, fill = median_price)) +
  geom_col() +
  geom_text(aes(label = paste0("n=", n)),
            hjust = -0.1, size = 2.7, color = "grey30") +
  scale_y_continuous(labels = label_dollar(),
                     expand = expansion(mult = c(0, 0.18))) +
  scale_fill_viridis_c(option = "magma", labels = label_dollar(),
                       name = "Precio\nmediano") +
  coord_flip() +
  labs(
    title    = "Precio mediano de venta por Barrio (Neighborhood)",
    subtitle = "Ordenado de menor a mayor precio mediano",
    x = NULL, y = "Precio mediano (USD)"
  ) + theme_hp
print(p_neigh)


# ------------------------------------------------------------------
# BLOQUE 8 — Distribución de precios por año (ridgeline plot)
# ------------------------------------------------------------------
p_ridge <- ggplot(train, aes(x = SalePrice, y = YrSold, fill = YrSold)) +
  geom_density_ridges(alpha = 0.70, scale = 1.10,
                      quantile_lines = TRUE,
                      quantiles      = c(0.25, 0.5, 0.75)) +
  scale_x_continuous(labels = label_dollar()) +
  scale_fill_brewer(palette = "Set2") +
  labs(
    title    = "Distribución de precios de venta por año",
    subtitle = "Las líneas verticales marcan Q1, mediana y Q3",
    x = "Precio de venta (USD)", y = "Año de venta"
  ) +
  theme_hp + theme(legend.position = "none")
print(p_ridge)


# ------------------------------------------------------------------
# BLOQUE 9 — Precio mediano y volumen de ventas por mes
# ------------------------------------------------------------------
p_mes <- train %>%
  group_by(MoSold) %>%
  summarise(median_price = median(SalePrice), n = n(), .groups = "drop") %>%
  ggplot(aes(x = MoSold, y = median_price, group = 1)) +
  geom_line(color = "#2C7BB6", linewidth = 1.2) +
  geom_point(aes(size = n), color = "#D7191C", alpha = 0.85) +
  scale_y_continuous(labels = label_dollar()) +
  labs(
    title    = "Precio mediano y volumen de ventas por mes",
    subtitle = "El tamaño del punto indica el número de transacciones",
    x = "Mes de venta", y = "Precio mediano (USD)", size = "Nº ventas"
  ) + theme_hp
print(p_mes)


# ------------------------------------------------------------------
# BLOQUE 10 — Variables indicadoras binarias (HasXxx)
# ------------------------------------------------------------------
bin_vars <- c("HasPool", "HasGarage", "HasFireplace", "HasBasement")

plots_bin <- lapply(bin_vars, function(v) {
  train %>%
    group_by(.data[[v]]) %>%
    summarise(mediana = median(SalePrice), n = n(), .groups = "drop") %>%
    ggplot(aes(x = .data[[v]], y = mediana, fill = .data[[v]])) +
    geom_col(width = 0.55) +
    geom_text(aes(label = paste0("n=", n)),
              vjust = -0.4, size = 3, color = "grey30") +
    scale_y_continuous(labels = label_dollar(),
                       expand = expansion(mult = c(0, 0.15))) +
    scale_fill_manual(values = c("No" = "#FC8D59", "Sí" = "#74ADD1")) +
    labs(title = v, x = NULL, y = "Precio mediano") +
    theme_minimal(base_size = 9) +
    theme(plot.title = element_text(face = "bold"),
          legend.position = "none")
})

do.call(grid.arrange, c(plots_bin, ncol = 4,
                        top = "Precio mediano según características adicionales de la vivienda"))


# ------------------------------------------------------------------
# BLOQUE 11 — Violin + Boxplot por tipo de edificio (BldgType)
# ------------------------------------------------------------------
p_bldg <- ggplot(train, aes(x = BldgType, y = SalePrice, fill = BldgType)) +
  geom_violin(trim = FALSE, alpha = 0.65) +
  geom_boxplot(width = 0.1, fill = "white",
               outlier.size = 0.5, outlier.alpha = 0.4) +
  scale_y_continuous(labels = label_dollar()) +
  scale_fill_brewer(palette = "Set1") +
  labs(
    title = "Distribución del precio de venta por tipo de edificio (BldgType)",
    x = "Tipo de edificio", y = "Precio de venta (USD)"
  ) +
  theme_hp + theme(legend.position = "none")
print(p_bldg)


# ------------------------------------------------------------------
# BLOQUE 12 — Frecuencias de variables categóricas clave
# ------------------------------------------------------------------
cat_key <- c(
  "MSZoning", "BldgType",    "HouseStyle",
  "Foundation","GarageType", "SaleCondition",
  "CentralAir","Neighborhood"
)

plots_bar <- lapply(cat_key, function(v) {
  tmp <- train %>%
    count(.data[[v]], name = "n") %>%
    arrange(desc(n)) %>%
    slice_head(n = 15) %>%
    mutate(nivel = fct_reorder(as.character(.data[[v]]), n))

  ggplot(tmp, aes(x = nivel, y = n)) +
    geom_col(fill = "#2CA25F", alpha = 0.85) +
    coord_flip() +
    labs(title = v, x = NULL, y = "Frec.") +
    theme_minimal(base_size = 8) +
    theme(plot.title = element_text(face = "bold", size = 8))
})

do.call(grid.arrange, c(plots_bar, ncol = 4,
                        top = "Frecuencias de variables categóricas clave"))


# ------------------------------------------------------------------
# BLOQUE 13 — Tabla de frecuencias: OverallQual
# ------------------------------------------------------------------
freq_qual <- train %>%
  count(OverallQual, name = "Frecuencia") %>%
  mutate(
    `Porcentaje (%)`      = round(100 * Frecuencia / sum(Frecuencia), 1),
    `Frec. acumulada`     = cumsum(Frecuencia),
    `Porc. acumulado (%)` = round(100 * cumsum(Frecuencia) / sum(Frecuencia), 1)
  ) %>%
  rename(`Calidad general` = OverallQual)

cat("\nTabla de frecuencias: OverallQual\n")
print(freq_qual)


# ------------------------------------------------------------------
# BLOQUE 14 — Tabla resumen: SalePrice por OverallQual
# ------------------------------------------------------------------
tab_qual <- train %>%
  group_by(OverallQual) %>%
  summarise(
    N       = n(),
    Mínimo  = dollar(min(SalePrice)),
    Q1      = dollar(quantile(SalePrice, 0.25)),
    Mediana = dollar(median(SalePrice)),
    Media   = dollar(round(mean(SalePrice))),
    Q3      = dollar(quantile(SalePrice, 0.75)),
    Máximo  = dollar(max(SalePrice)),
    DT      = dollar(round(sd(SalePrice))),
    .groups = "drop"
  )

cat("\nEstadísticos de SalePrice por Calidad General (OverallQual):\n")
print(tab_qual)


# ------------------------------------------------------------------
# BLOQUE 15 — Matriz de correlación (variables numéricas clave)
# ------------------------------------------------------------------
cor_vars <- c(
  "SalePrice",  "GrLivArea",    "LotArea",     "LotFrontage",
  "TotalBsmtSF","GarageArea",   "TotalSF",     "TotalBaths",
  "HouseAge",   "RemodAge",     "TotRmsAbvGrd","Fireplaces",
  "WoodDeckSF", "OpenPorchSF",  "OverallQual_n","QualSF"
)

train_cor <- train %>%
  mutate(OverallQual_n = as.numeric(OverallQual)) %>%
  select(all_of(cor_vars))

cor_mat <- cor(train_cor, use = "pairwise.complete.obs")

par(mar = c(0, 0, 3, 0))
corrplot(
  cor_mat,
  method      = "color",
  type        = "upper",
  order       = "hclust",
  tl.cex      = 0.78,
  tl.col      = "black",
  addCoef.col = "black",
  number.cex  = 0.52,
  col         = colorRampPalette(c("#D7191C", "white", "#2C7BB6"))(200),
  title       = "Matriz de correlación — variables numéricas clave (incl. QualSF)",
  mar         = c(0, 0, 2, 0)
)


# ------------------------------------------------------------------
# BLOQUE 16 — Top 10 correlaciones con SalePrice
# ------------------------------------------------------------------
cor_sp  <- cor_mat["SalePrice", ]
top_cor <- sort(abs(cor_sp[names(cor_sp) != "SalePrice"]), decreasing = TRUE)[1:10]

p_cor <- data.frame(
  Variable    = names(top_cor),
  Correlacion = as.numeric(top_cor)
) %>%
  mutate(Variable = fct_reorder(Variable, Correlacion)) %>%
  ggplot(aes(x = Variable, y = Correlacion, fill = Correlacion)) +
  geom_col() +
  geom_text(aes(label = round(Correlacion, 3)),
            hjust = -0.1, size = 3.2) +
  scale_fill_gradient(low = "#FEE090", high = "#D7191C") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.15))) +
  coord_flip() +
  labs(
    title    = "Top 10: Variables con mayor correlación con SalePrice",
    subtitle = "Valor absoluto de la correlación de Pearson",
    x = NULL, y = "|r de Pearson|", fill = "|r|"
  ) + theme_hp
print(p_cor)


# ==============================================================
# b.2) GRÁFICOS INTERACTIVOS (plotly)
# ==============================================================

# --- Interactivo 1: SalePrice vs TotalSF ----------------------
df_inter <- train %>%
  mutate(
    OverallQual_n = as.numeric(OverallQual),
    SP_fmt        = scales::dollar(SalePrice),
    SF_fmt        = scales::comma(TotalSF)
  )

p_interactive <- plot_ly(
  data      = df_inter,
  x         = ~TotalSF,
  y         = ~SalePrice,
  color     = ~OverallQual_n,
  colors    = viridis(10, option = "plasma"),
  type      = "scatter",
  mode      = "markers",
  marker    = list(size = 6, opacity = 0.65),
  text      = ~paste0(
    "<b>Precio de venta:</b> ",   SP_fmt,
    "<br><b>Superficie total:</b> ", SF_fmt, " sq ft",
    "<br><b>Barrio:</b> ",         Neighborhood,
    "<br><b>Calidad general:</b> ",OverallQual,
    "<br><b>Tipo de edificio:</b> ",BldgType,
    "<br><b>Estilo de la casa:</b> ",HouseStyle,
    "<br><b>Año construido:</b> ", YearBuilt,
    "<br><b>Año vendido:</b> ",    YrSold,
    "<br><b>Condición venta:</b> ",SaleCondition
  ),
  hoverinfo = "text"
) %>%
  layout(
    title = list(
      text = paste0(
        "<b>Precio de venta vs Superficie Total</b><br>",
        "<sup>Coloreado por Calidad General (1–10) — ",
        "House Prices · Ames, Iowa · Kaggle</sup>"
      ),
      font = list(size = 15)
    ),
    xaxis     = list(title = "Superficie total (sq ft)", tickformat = ","),
    yaxis     = list(title = "Precio de venta (USD)", tickprefix = "$", tickformat = ","),
    coloraxis = list(colorbar = list(title = "<b>Calidad<br>General</b>", tickvals = 1:10)),
    hovermode     = "closest",
    plot_bgcolor  = "#F8F9FA",
    paper_bgcolor = "#FFFFFF",
    font          = list(family = "Arial")
  )
print(p_interactive)


# --- Interactivo 2: SalePrice vs QualSF (feature reina) -------
df_inter_reina <- train %>%
  mutate(
    OverallQual_n = as.numeric(OverallQual),
    SP_fmt        = scales::dollar(SalePrice),
    QualSF_fmt    = scales::comma(QualSF),
    TotalSF_fmt   = scales::comma(TotalSF)
  )

p_interactive_reina <- plot_ly(
  data      = df_inter_reina,
  x         = ~QualSF,
  y         = ~SalePrice,
  color     = ~OverallQual_n,
  colors    = viridis(10, option = "plasma"),
  type      = "scatter",
  mode      = "markers",
  marker    = list(size = 6, opacity = 0.65),
  text      = ~paste0(
    "<b>Precio de venta:</b> ",       SP_fmt,
    "<br><b>QualSF (reina):</b> ",    QualSF_fmt,
    "<br><b>Superficie total:</b> ",  TotalSF_fmt, " sq ft",
    "<br><b>Barrio:</b> ",            Neighborhood,
    "<br><b>Calidad general:</b> ",   OverallQual,
    "<br><b>Tipo de edificio:</b> ",  BldgType,
    "<br><b>Estilo de la casa:</b> ", HouseStyle,
    "<br><b>Año construido:</b> ",    YearBuilt,
    "<br><b>Año vendido:</b> ",       YrSold,
    "<br><b>Condición venta:</b> ",   SaleCondition
  ),
  hoverinfo = "text"
) %>%
  layout(
    title = list(
      text = paste0(
        "<b>Precio de venta vs Feature reina (QualSF = OverallQual × TotalSF)</b><br>",
        "<sup>Coloreado por Calidad General (1–10) — House Prices · Ames, Iowa · Kaggle</sup>"
      ),
      font = list(size = 15)
    ),
    xaxis     = list(title = "QualSF (OverallQual × TotalSF)", tickformat = ","),
    yaxis     = list(title = "Precio de venta (USD)", tickprefix = "$", tickformat = ","),
    coloraxis = list(colorbar = list(title = "Calidad<br>General", tickvals = 1:10)),
    hovermode     = "closest",
    plot_bgcolor  = "#F8F9FA",
    paper_bgcolor = "#FFFFFF",
    font          = list(family = "Arial")
  )
print(p_interactive_reina)


# ==============================================================
cat("\n", strrep("=", 65), "\n")
cat("✓ Análisis completado con éxito.\n")
cat(strrep("=", 65), "\n")
