# ==============================================================
# ANÁLISIS EXPLORATORIO: House Prices – Advanced Regression
# Kaggle: house-prices-advanced-regression-techniques
# URL   : https://www.kaggle.com/competitions/
#         house-prices-advanced-regression-techniques
# ==============================================================


# ==============================================================
# 0. INSTALACIÓN Y CARGA DE LIBRERÍAS
# ==============================================================

rm(list = ls())
dev.off()

pkgs <- c(
  "tidyverse", "skimr",    "naniar",   "corrplot",
  "plotly",    "scales",   "gridExtra","moments",
  "ggridges",  "viridis",  "ggrepel"
)
for (p in pkgs) {
  if (!requireNamespace(p, quietly = TRUE)) install.packages(p)
}

library(tidyverse)
library(skimr)
library(naniar)
library(corrplot)
library(plotly)
library(scales)
library(gridExtra)
library(moments)
library(ggridges)
library(viridis)
library(ggrepel)

# Tema gráfico personalizado
theme_hp <- theme_minimal(base_size = 11) +
  theme(
    plot.title    = element_text(face = "bold", size = 13, hjust = 0),
    plot.subtitle = element_text(color = "grey40", size = 10),
    axis.title    = element_text(size = 10),
    legend.title  = element_text(face = "bold", size = 9),
    strip.text    = element_text(face = "bold")
  )


# ==============================================================
# a) PREPARACIÓN DE LOS DATOS
# ==============================================================

# --------------------------------------------------------------
# a.1) DESCRIPCIÓN DEL CONJUNTO ORIGINAL
# --------------------------------------------------------------
cat(strrep("=", 65), "\n")
cat("NOMBRE   : House Prices – Advanced Regression Techniques\n")
cat("FUENTE   : Kaggle\n")
cat("ENLACE   : https://www.kaggle.com/competitions/\n")
cat("           house-prices-advanced-regression-techniques\n")
cat("CONTEXTO : Precios de venta de viviendas residenciales\n")
cat("           en Ames, Iowa (EE.UU.) — años 2006-2010\n")
cat(strrep("=", 65), "\n\n")

# !! Ajusta la ruta a la ubicación de tu archivo train.csv !!
train_raw <- read.csv("~/Análisis de Datos/Trabajo ADAT/House-prices/train.csv", header = TRUE, stringsAsFactors = FALSE)

n_obs  <- nrow(train_raw)
n_vars <- ncol(train_raw)
n_num  <- sum(sapply(train_raw, is.numeric))
n_chr  <- sum(sapply(train_raw, is.character))

cat(sprintf("Número de individuos (filas)     : %d\n",   n_obs))
cat(sprintf("Número de variables (columnas)   : %d\n",   n_vars))
cat(sprintf("  - Variables numéricas          : %d\n",   n_num))
cat(sprintf("  - Variables de texto (categ.)  : %d\n\n", n_chr))

cat("Variables del dataset:\n")
print(names(train_raw))

cat("\nPrimeras 5 filas (primeras 10 columnas):\n")
print(head(train_raw[, 1:10], 5))


# --------------------------------------------------------------
# a.2) TRANSFORMACIÓN, LIMPIEZA E IMPUTACIÓN
# --------------------------------------------------------------
train <- train_raw  # copia de trabajo: train_raw queda intacto

# Renombrar variables con nombres no sintácticos en R
# (nombres que empiezan por número causan problemas en tidyverse)
train <- train %>%
  rename(FlrSF_1st  = X1stFlrSF,
         FlrSF_2nd  = X2ndFlrSF,
         Porch_3Ssn = X3SsnPorch)


# --- PASO 1: Diagnóstico de valores perdidos ------------------
miss_df <- data.frame(
  Variable    = names(train),
  N_Missing   = colSums(is.na(train)),
  Pct_Missing = round(100 * colMeans(is.na(train)), 2)
) %>%
  filter(N_Missing > 0) %>%
  arrange(desc(Pct_Missing))

cat("\n--- Diagnóstico de valores perdidos (antes de imputar) ---\n")
print(miss_df, row.names = FALSE)

# Visualización: gráfico de barras por % de NAs por variable
p_miss <- gg_miss_var(train, show_pct = TRUE) +
  labs(
    title    = "Porcentaje de valores faltantes por variable",
    subtitle = sprintf("House Prices — Kaggle  (n = %d obs., %d vars.)",
                       n_obs, n_vars),
    y = "% Missing"
  ) + theme_hp
print(p_miss)


# --- PASO 1.5: Eliminar variables insignificativas (>80% NA) ---
umbral_na <- 80
vars_insig <- miss_df$Variable[miss_df$Pct_Missing > umbral_na]
cat(sprintf("\nVariables eliminadas por exceso de NAs (>%d%%) al no aportar información: %s\n", 
            umbral_na, paste(vars_insig, collapse = ", ")))

train <- train %>% select(-all_of(vars_insig))

# --- PASO 2: Imputación semántica (según data dictionary) -----
na_none_cat <- c(
  "Alley", "MasVnrType", "BsmtQual", "BsmtCond",
  "BsmtExposure", "BsmtFinType1", "BsmtFinType2","FireplaceQu",
  "GarageType", "GarageFinish", "GarageQual", "GarageCond",
  "PoolQC", "Fence", "MiscFeature"
)
# Retener solo aquellas que no han sido eliminadas
na_none_cat <- intersect(na_none_cat, names(train))

for (v in na_none_cat) {
  train[[v]][is.na(train[[v]])] <- "None"
}

na_zero_num <- c(
  "MasVnrArea", "BsmtFinSF1", "BsmtFinSF2", "BsmtUnfSF",
  "TotalBsmtSF","BsmtFullBath", "BsmtHalfBath",
  "GarageCars", "GarageArea", "GarageYrBlt"
)

for (v in na_zero_num) {
  train[[v]][is.na(train[[v]])] <- 0
}

train <- train %>%
  group_by(Neighborhood) %>%
  mutate(LotFrontage = if_else(
    is.na(LotFrontage),
    median(LotFrontage, na.rm = TRUE),
    as.double(LotFrontage)
  )) %>%
  ungroup()

moda_elec <- names(which.max(table(train$Electrical)))
train$Electrical[is.na(train$Electrical)] <- moda_elec


# --- PASO 3: Feature Engineering ------------------------------
# Se extraen las nuevas variables ANTES de convertir YrSold a factor,
# porque las operaciones aritméticas requieren valores numéricos.
yr_num <- as.integer(as.character(train$YrSold))

train <- train %>%
  mutate(
    # Antigüedad de la vivienda en el momento de la venta
    HouseAge     = yr_num - YearBuilt,
    # Años desde la última remodelación
    RemodAge     = yr_num - YearRemodAdd,
    # Superficie total: sótano + planta baja + planta alta
    TotalSF      = TotalBsmtSF + FlrSF_1st + FlrSF_2nd,
    # Baños totales: completos cuentan 1, medios baños 0.5
    # (convención estándar del sector inmobiliario)
    TotalBaths   = FullBath + 0.5 * HalfBath +
      BsmtFullBath + 0.5 * BsmtHalfBath,
    # Variables indicadoras: presencia de la característica
    HasPool      = factor(ifelse(PoolArea    > 0, "Sí", "No")),
    HasGarage    = factor(ifelse(GarageArea  > 0, "Sí", "No")),
    HasFireplace = factor(ifelse(Fireplaces  > 0, "Sí", "No")),
    HasBasement  = factor(ifelse(TotalBsmtSF > 0, "Sí", "No")),
    # Transformación logarítmica de la variable respuesta
    # (normaliza la distribución sesgada de SalePrice)
    logSalePrice = log(SalePrice)
  ) %>%
  mutate(
    # "Feature reina": calidad general × superficie total
    # Captura simultáneamente tamaño Y calidad → correlación ~0.88
    QualSF       = as.integer(OverallQual) * TotalSF,
    # Superficie total de porches
    TotalPorchSF = OpenPorchSF + EnclosedPorch + Porch_3Ssn + ScreenPorch
  )

# Verificar correlación de las nuevas variables con SalePrice
new_feats <- c("QualSF", "TotalSF", "TotalBaths",
               "TotalPorchSF", "HouseAge", "RemodAge", "SalePrice")
cor_new <- cor(
  train %>% select(all_of(new_feats)),
  use = "pairwise.complete.obs"
)["SalePrice", ] %>% sort(decreasing = TRUE)

cat("\nCorrelación de las variables derivadas con SalePrice:\n")
print(round(cor_new, 3))


# --- PASO 4: Conversión al tipo de dato correcto --------------

# MSSubClass: código numérico que representa tipo de vivienda,
# no una magnitud → factor nominal
train$MSSubClass <- factor(train$MSSubClass)

# OverallQual / OverallCond: escala 1–10 con orden real → ordinal
train$OverallQual <- factor(train$OverallQual, levels = 1:10, ordered = TRUE)
train$OverallCond <- factor(train$OverallCond, levels = 1:10, ordered = TRUE)

# MoSold: número del mes → factor con etiquetas legibles
train$MoSold <- factor(train$MoSold, levels = 1:12, labels = month.abb)

# YrSold: año de venta → factor nominal
train$YrSold <- factor(train$YrSold)

# Variables de calidad con escala estandarizada Po→Ex
# "None" se incluye como primer nivel (casas sin esa característica)
quality_levels <- c("None", "Po", "Fa", "TA", "Gd", "Ex")
ord_qual_vars  <- c(
  "ExterQual", "ExterCond",  "BsmtQual",   "BsmtCond",
  "HeatingQC", "KitchenQual","FireplaceQu",
  "GarageQual","GarageCond"
)
for (v in ord_qual_vars) {
  train[[v]] <- factor(train[[v]], levels = quality_levels, ordered = TRUE)
}

# Resto de variables de texto → factor nominal
chr_vars <- names(train)[sapply(train, is.character)]
train[chr_vars] <- lapply(train[chr_vars], factor)


# --- PASO 5: Verificación final de valores perdidos -----------
n_na_restantes <- sum(is.na(train))
cat(sprintf("\nValores perdidos tras la imputación: %d\n", n_na_restantes))
if (n_na_restantes > 0) {
  cat("Variables con NAs restantes:\n")
  print(names(which(colSums(is.na(train)) > 0)))
}



# ==============================================================
# a.4) TRATAMIENTO DE OUTLIERS E IMPUTACIÓN k-NN
# ==============================================================
# Referencia: PDF de teoría
# 1. Detección: Hubert, M. y Vandervieren, E. (2008) - Boxplot ajustado (Medcouple).
# 2. Imputación: VIM::kNN - Agregación k-Nearest Neighbors con distancia de Gower.

out_vars <- c(
  "SalePrice", "GrLivArea", "LotArea", "LotFrontage",
  "TotalSF", "TotalBsmtSF","GarageArea", "TotalBaths",
  "HouseAge", "QualSF"
)

# Guardamos una copia del dataset original para la comparativa visual posterior
train_pre_outliers <- train

cat("\n", strrep("=", 65), "\n")
cat("PASO 6 — DIAGNÓSTICO DE OUTLIERS (Hubert & Vandervieren)\n")
cat(strrep("=", 65), "\n")

# --- Justificación Visual: Tukey vs Boxplot Ajustado ---
# Tomamos SalePrice como ejemplo de distribución asimétrica positiva
sp_clean <- train$SalePrice[!is.na(train$SalePrice)]
q1 <- quantile(sp_clean, 0.25)
q3 <- quantile(sp_clean, 0.75)
iqr <- q3 - q1
lim_tukey_sup <- q3 + 1.5 * iqr
lim_adj_sup <- robustbase::adjboxStats(sp_clean)$fence[2]

p_justificacion <- ggplot(train, aes(x = SalePrice)) +
  geom_density(fill = "#2C7BB6", alpha = 0.4, color = "black", linewidth = 0.8) +
  geom_vline(xintercept = lim_tukey_sup, color = "#D7191C", linetype = "dashed", linewidth = 1) +
  geom_vline(xintercept = lim_adj_sup, color = "#1A9641", linetype = "solid", linewidth = 1) +
  annotate("text", x = lim_tukey_sup, y = 0.000004, label = "Límite Clásico (Tukey)", color = "#D7191C", angle = 90, vjust = -0.5, size = 3.5, fontface = "bold") +
  annotate("text", x = lim_adj_sup, y = 0.000004, label = "Límite Ajustado (Medcouple)", color = "#1A9641", angle = 90, vjust = -0.5, size = 3.5, fontface = "bold") +
  scale_x_continuous(labels = label_dollar()) +
  labs(
    title = "Justificación: Método Clásico vs Boxplot Ajustado por Asimetría",
    subtitle = "El método clásico asume simetría y genera demasiados falsos atípicos en la cola derecha.\nEl Medcouple adapta el límite a la asimetría real (Hubert & Vandervieren).",
    x = "Precio de Venta (USD)", y = "Densidad"
  ) + theme_hp

print(p_justificacion)

# --- Aplicación del método ---
diag_out <- do.call(rbind, lapply(out_vars, function(v) {
  x <- train[[v]]
  
  # Límite ajustado por la medida robusta de asimetría (medcouple)
  bx_stats <- robustbase::adjboxStats(x[!is.na(x)])
  lim_inf <- bx_stats$fence[1]
  lim_sup <- bx_stats$fence[2]
  
  is_outlier <- !is.na(x) & (x < lim_inf | x > lim_sup)
  n_out <- sum(is_outlier)
  
  # Asignamos NA a los outliers para su posterior imputación
  train[[v]][is_outlier] <<- NA
  
  data.frame(
    Variable = v,
    Lim_Inf = round(lim_inf, 1),
    Lim_Sup = round(lim_sup, 1),
    N_out = n_out,
    Pct_out = round(100 * n_out / sum(!is.na(x)), 1)
  )
})) %>% arrange(desc(Pct_out))

print(diag_out, row.names = FALSE)


# --- PASO 7: Imputación k-NN ----------------------------------
cat("\nPASO 7 — AGREGACIÓN: Imputación k-NN (VIM)\n")
cat("Se utiliza k=5 (por defecto en la literatura y VIM) porque es un heurístico robusto:\n")
cat(" - Un k muy bajo (ej. k=1) tiene alta varianza y es sensible al ruido.\n")
cat(" - Un k muy alto sobre-suaviza los datos, perdiendo la variabilidad local.\n")
cat("La imputación usa la distancia de Gower, preservando las relaciones multivariantes.\n")

# Se imputan los NAs usando la mediana de los 5 vecinos más parecidos
# imp_var = FALSE evita que se creen columnas booleanas innecesarias en el dataset
train <- VIM::kNN(train, variable = out_vars, k = 5, imp_var = FALSE)


# --- Visualización comparativa Antes vs Después ---------------
vars_plot <- c("SalePrice", "GrLivArea", "LotArea", "TotalSF")

# Preparamos los datos en formato largo para ggplot
df_comp <- bind_rows(
  train_pre_outliers %>% select(all_of(vars_plot)) %>% mutate(Fase = "1. Original (Con Outliers)"),
  train %>% select(all_of(vars_plot)) %>% mutate(Fase = "2. Post-Imputación (k-NN, k=5)")
) %>%
  pivot_longer(cols = -Fase, names_to = "Variable", values_to = "Valor")

p_comparativa <- ggplot(df_comp, aes(x = Fase, y = Valor, fill = Fase)) +
  geom_boxplot(alpha = 0.7, outlier.alpha = 0.5, outlier.size = 1) +
  facet_wrap(~Variable, scales = "free_y") +
  scale_y_continuous(labels = label_comma()) +
  scale_fill_manual(values = c("1. Original (Con Outliers)" = "#FC8D59", "2. Post-Imputación (k-NN, k=5)" = "#74ADD1")) +
  labs(
    title = "Efecto del tratamiento de outliers y agregación k-NN",
    subtitle = "Los valores extremos se identificaron mediante Boxplot Ajustado y se imputaron mediante VIM::kNN\nbasándose en los 5 vecinos más similares (distancia de Gower).",
    x = NULL, y = "Valor"
  ) +
  theme_hp + 
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 15, hjust = 1, face = "bold"),
    strip.text = element_text(size = 11, face = "bold", color = "#2C7BB6")
  )

print(p_comparativa)

cat("\n✓ Tratamiento de outliers completado: Datos extremos suavizados mediante k-NN.\n")



# --------------------------------------------------------------
# a.3) RESUMEN FINAL DEL CONJUNTO
# --------------------------------------------------------------
cat("\n", strrep("=", 65), "\n")
cat("RESUMEN FINAL (TRAS PREPROCESADO)\n")
cat(strrep("=", 65), "\n")
cat(sprintf("Individuos                : %d\n",  nrow(train)))
cat(sprintf("Variables totales         : %d\n",  ncol(train)))
cat(sprintf("  - Numéricas             : %d\n",  sum(sapply(train, is.numeric))))
cat(sprintf("  - Factor / Ordinal      : %d\n",  sum(sapply(train, is.factor))))
cat(sprintf("  - Valores perdidos      : %d\n\n",sum(is.na(train))))

print(skim(train))



# ==============================================================
# b) ANÁLISIS EXPLORATORIO DE DATOS (EDA)
# ==============================================================

# ==============================================================
# b.1) ESTUDIO DESCRIPTIVO
# ==============================================================


# ------------------------------------------------------------------
# BLOQUE 0 — Prueba de normalidad de la variable respuesta
# ------------------------------------------------------------------
cat("\n", strrep("=", 65), "\n")
cat("PRUEBA DE NORMALIDAD DE LILLIEFORS (SalePrice)\n")
cat(strrep("=", 65), "\n")

sp_validos <- train$SalePrice[!is.na(train$SalePrice)]
test_lillie <- nortest::lillie.test(sp_validos)
print(test_lillie)
cat(sprintf("\nComo el p-valor (%.4e) es menor a 0.05, rechazamos H0.\n", test_lillie$p.value))
cat("SalePrice NO sigue una distribución normal, por lo que usaremos correlación de Spearman.\n\n")


# ------------------------------------------------------------------
# BLOQUE 1 — Distribución de la variable respuesta: SalePrice
# ------------------------------------------------------------------
p_sp1 <- ggplot(train, aes(x = SalePrice)) +
  geom_histogram(aes(y = after_stat(density)), bins = 50,
                 fill = "#2C7BB6", alpha = 0.75, color = "white") +
  geom_density(color = "#D7191C", linewidth = 1.1) +
  scale_x_continuous(labels = label_dollar()) +
  labs(
    title    = "Distribución de SalePrice (precio de venta)",
    subtitle = sprintf("n = %d  |  Media = %s  |  Mediana = %s  |  Asimetría = %.2f  |  Curtosis = %.2f",
                       nrow(train),
                       dollar(round(mean(train$SalePrice))),
                       dollar(median(train$SalePrice)),
                       skewness(train$SalePrice),
                       kurtosis(train$SalePrice)),
    x = "Precio de venta (USD)", y = "Densidad"
  ) + theme_hp

p_sp2 <- ggplot(train, aes(x = logSalePrice)) +
  geom_histogram(aes(y = after_stat(density)), bins = 50,
                 fill = "#1A9641", alpha = 0.75, color = "white") +
  geom_density(color = "#D7191C", linewidth = 1.1) +
  labs(
    title    = "Distribución de log(SalePrice)",
    subtitle = sprintf("La transformación logarítmica normaliza la distribución  |  Asimetría = %.2f  |  Curtosis = %.2f",
                       skewness(train$logSalePrice),
                       kurtosis(train$logSalePrice)),
    x = "log(Precio de venta)", y = "Densidad"
  ) + theme_hp

grid.arrange(p_sp1, p_sp2, ncol = 2,
             top = "Variable respuesta: SalePrice y su transformación logarítmica")


# ------------------------------------------------------------------
# BLOQUE 2 — Tabla de estadísticos descriptivos (vars. numéricas)
# ------------------------------------------------------------------
num_vars_key <- c(
  "SalePrice", "LotArea",    "LotFrontage", "GrLivArea",
  "TotalSF",   "TotalBsmtSF","FlrSF_1st",   "FlrSF_2nd",
  "GarageArea","TotalBaths", "HouseAge",    "RemodAge",
  "Fireplaces","TotRmsAbvGrd","WoodDeckSF", "OpenPorchSF"
)

stats_tbl <- train %>%
  select(all_of(num_vars_key)) %>%
  pivot_longer(everything(), names_to = "Variable", values_to = "Valor") %>%
  group_by(Variable) %>%
  summarise(
    N       = sum(!is.na(Valor)),
    Media   = round(mean(Valor,            na.rm = TRUE), 1),
    Mediana = round(median(Valor,          na.rm = TRUE), 1),
    DT      = round(sd(Valor,             na.rm = TRUE), 1),
    Min     = round(min(Valor,            na.rm = TRUE), 1),
    Q1      = round(quantile(Valor, 0.25, na.rm = TRUE), 1),
    Q3      = round(quantile(Valor, 0.75, na.rm = TRUE), 1),
    Max     = round(max(Valor,            na.rm = TRUE), 1),
    Asim    = round(skewness(Valor,       na.rm = TRUE), 2),
    Kurt    = round(kurtosis(Valor,       na.rm = TRUE), 2),
    .groups = "drop"
  ) %>%
  arrange(desc(abs(Asim)))

cat("\nTabla de estadísticos descriptivos — variables numéricas clave:\n")
print(stats_tbl, n = Inf)


# ------------------------------------------------------------------
# BLOQUE 3 — Histogramas en mosaico (variables numéricas clave)
# ------------------------------------------------------------------
hist_vars <- c(
  "LotArea", "GrLivArea", "TotalBsmtSF", "GarageArea",
  "TotalSF", "TotalBaths","HouseAge",    "LotFrontage"
)

plots_hist <- lapply(hist_vars, function(v) {
  ggplot(train, aes(x = .data[[v]])) +
    geom_histogram(bins = 40, fill = "#4393C3", alpha = 0.85, color = "white") +
    scale_x_continuous(labels = label_comma()) +
    labs(title = v, x = NULL, y = "Frec.") +
    theme_minimal(base_size = 8) +
    theme(plot.title = element_text(face = "bold", size = 9))
})

do.call(grid.arrange, c(plots_hist, ncol = 4,
                        top = "Distribución de variables numéricas clave"))


# ------------------------------------------------------------------
# BLOQUE 4 — Boxplot: SalePrice por calidad general (OverallQual)
# ------------------------------------------------------------------
p_qual <- ggplot(train, aes(x = OverallQual, y = SalePrice, fill = OverallQual)) +
  geom_boxplot(outlier.alpha = 0.35, outlier.size = 0.8) +
  scale_y_continuous(labels = label_dollar()) +
  scale_fill_viridis_d(option = "plasma") +
  labs(
    title    = "Precio de venta por Calidad General (OverallQual)",
    subtitle = "Escala ordinal: 1 = Muy deficiente → 10 = Excelente",
    x = "Calidad general", y = "Precio de venta (USD)"
  ) +
  theme_hp + theme(legend.position = "none")
print(p_qual)


# ------------------------------------------------------------------
# BLOQUE 5 — Scatterplot: SalePrice vs GrLivArea
# ------------------------------------------------------------------
p_scatter1 <- ggplot(train,
                     aes(x = GrLivArea, y = SalePrice,
                         color = as.numeric(OverallQual))) +
  geom_point(alpha = 0.45, size = 1.5) +
  geom_smooth(method = "lm", color = "black",
              se = TRUE, linewidth = 0.9, linetype = "dashed") +
  scale_y_continuous(labels = label_dollar()) +
  scale_x_continuous(labels = label_comma()) +
  scale_color_viridis_c(option = "plasma", name = "Calidad\nGeneral") +
  labs(
    title    = "SalePrice vs Superficie habitable (GrLivArea)",
    subtitle = sprintf("Correlación de Pearson: r = %.3f",
                       cor(train$SalePrice, train$GrLivArea)),
    x = "Superficie habitable (sq ft)", y = "Precio de venta (USD)"
  ) + theme_hp
print(p_scatter1)


# ------------------------------------------------------------------
# BLOQUE 6 — Scatterplot: SalePrice vs TotalSF (variable creada)
# ------------------------------------------------------------------
p_scatter2 <- ggplot(train,
                     aes(x = TotalSF, y = SalePrice,
                         color = as.numeric(OverallQual))) +
  geom_point(alpha = 0.45, size = 1.5) +
  geom_smooth(method = "lm", color = "black",
              se = TRUE, linewidth = 0.9, linetype = "dashed") +
  scale_y_continuous(labels = label_dollar()) +
  scale_x_continuous(labels = label_comma()) +
  scale_color_viridis_c(option = "plasma", name = "Calidad\nGeneral") +
  labs(
    title    = "SalePrice vs Superficie Total (TotalSF = sótano + P.baja + P.alta)",
    subtitle = sprintf("Correlación de Pearson: r = %.3f",
                       cor(train$SalePrice, train$TotalSF)),
    x = "Superficie total (sq ft)", y = "Precio de venta (USD)"
  ) + theme_hp
print(p_scatter2)


# ------------------------------------------------------------------
# BLOQUE 7 — Precio mediano por Neighborhood (todos los barrios)
# ------------------------------------------------------------------
p_neigh <- train %>%
  group_by(Neighborhood) %>%
  summarise(median_price = median(SalePrice), n = n(), .groups = "drop") %>%
  mutate(Neighborhood = fct_reorder(Neighborhood, median_price)) %>%
  ggplot(aes(x = Neighborhood, y = median_price, fill = median_price)) +
  geom_col() +
  geom_text(aes(label = paste0("n=", n)),
            hjust = -0.1, size = 2.7, color = "grey30") +
  scale_y_continuous(labels = label_dollar(),
                     expand = expansion(mult = c(0, 0.18))) +
  scale_fill_viridis_c(option = "magma", labels = label_dollar(),
                       name = "Precio\nmediano") +
  coord_flip() +
  labs(
    title    = "Precio mediano de venta por Barrio (Neighborhood)",
    subtitle = "Ordenado de menor a mayor precio mediano",
    x = NULL, y = "Precio mediano (USD)"
  ) + theme_hp
print(p_neigh)


# ------------------------------------------------------------------
# BLOQUE 8 — Evolución del precio según la antigüedad de la casa
# ------------------------------------------------------------------
p_age <- ggplot(train, aes(x = HouseAge, y = SalePrice)) +
  geom_point(alpha = 0.45, color = "#2C7BB6") +
  geom_smooth(method = "loess", color = "#D7191C", se = TRUE, linetype = "dashed") +
  scale_y_continuous(labels = label_dollar()) +
  labs(
    title = "Precio de venta vs Antigüedad de la vivienda (HouseAge)",
    subtitle = sprintf("Correlación de Spearman: rho = %.3f", 
                       cor(train$SalePrice, train$HouseAge, use="pairwise.complete.obs", method="spearman")),
    x = "Antigüedad (años)", y = "Precio de venta (USD)"
  ) + theme_hp
print(p_age)


# ------------------------------------------------------------------
# BLOQUE 9 — Precio mediano y volumen de ventas por mes
# ------------------------------------------------------------------
p_mes <- train %>%
  group_by(MoSold) %>%
  summarise(median_price = median(SalePrice), n = n(), .groups = "drop") %>%
  ggplot(aes(x = MoSold, y = median_price, group = 1)) +
  geom_line(color = "#2C7BB6", linewidth = 1.2) +
  geom_point(aes(size = n), color = "#D7191C", alpha = 0.85) +
  scale_y_continuous(labels = label_dollar()) +
  labs(
    title    = "Precio mediano y volumen de ventas por mes",
    subtitle = "El tamaño del punto indica el número de transacciones",
    x = "Mes de venta", y = "Precio mediano (USD)", size = "Nº ventas"
  ) + theme_hp
print(p_mes)


# ------------------------------------------------------------------
# BLOQUE 10 — Variables indicadoras binarias (HasXxx)
# ------------------------------------------------------------------
bin_vars <- c("HasPool", "HasGarage", "HasFireplace", "HasBasement")

plots_bin <- lapply(bin_vars, function(v) {
  train %>%
    group_by(.data[[v]]) %>%
    summarise(mediana = median(SalePrice), n = n(), .groups = "drop") %>%
    ggplot(aes(x = .data[[v]], y = mediana, fill = .data[[v]])) +
    geom_col(width = 0.55) +
    geom_text(aes(label = paste0("n=", n)),
              vjust = -0.4, size = 3, color = "grey30") +
    scale_y_continuous(labels = label_dollar(),
                       expand = expansion(mult = c(0, 0.15))) +
    scale_fill_manual(values = c("No" = "#FC8D59", "Sí" = "#74ADD1")) +
    labs(title = v, x = NULL, y = "Precio mediano") +
    theme_minimal(base_size = 9) +
    theme(plot.title = element_text(face = "bold"),
          legend.position = "none")
})

do.call(grid.arrange, c(plots_bin, ncol = 4,
                        top = "Precio mediano según características adicionales de la vivienda"))


# ------------------------------------------------------------------
# BLOQUE 11 — Violin + Boxplot por tipo de edificio (BldgType)
# ------------------------------------------------------------------
p_bldg <- ggplot(train, aes(x = BldgType, y = SalePrice, fill = BldgType)) +
  geom_violin(trim = FALSE, alpha = 0.65) +
  geom_boxplot(width = 0.1, fill = "white",
               outlier.size = 0.5, outlier.alpha = 0.4) +
  scale_y_continuous(labels = label_dollar()) +
  scale_fill_brewer(palette = "Set1") +
  labs(
    title = "Distribución del precio de venta por tipo de edificio (BldgType)",
    x = "Tipo de edificio", y = "Precio de venta (USD)"
  ) +
  theme_hp + theme(legend.position = "none")
print(p_bldg)


# ------------------------------------------------------------------
# BLOQUE 12 — Frecuencias de variables categóricas clave
# ------------------------------------------------------------------
cat_key <- c(
  "MSZoning", "BldgType",    "HouseStyle",
  "Foundation","GarageType", "SaleCondition",
  "CentralAir","Neighborhood"
)

plots_bar <- lapply(cat_key, function(v) {
  tmp <- train %>%
    count(.data[[v]], name = "n") %>%
    arrange(desc(n)) %>%
    slice_head(n = 15) %>%
    mutate(nivel = fct_reorder(as.character(.data[[v]]), n))
  
  ggplot(tmp, aes(x = nivel, y = n)) +
    geom_col(fill = "#2CA25F", alpha = 0.85) +
    coord_flip() +
    labs(title = v, x = NULL, y = "Frec.") +
    theme_minimal(base_size = 8) +
    theme(plot.title = element_text(face = "bold", size = 8))
})

do.call(grid.arrange, c(plots_bar, ncol = 4,
                        top = "Frecuencias de variables categóricas clave"))


# ------------------------------------------------------------------
# BLOQUE 13 — Tabla de frecuencias: OverallQual
# ------------------------------------------------------------------
freq_qual <- train %>%
  count(OverallQual, name = "Frecuencia") %>%
  mutate(
    `Porcentaje (%)`      = round(100 * Frecuencia / sum(Frecuencia), 1),
    `Frec. acumulada`     = cumsum(Frecuencia),
    `Porc. acumulado (%)` = round(100 * cumsum(Frecuencia) / sum(Frecuencia), 1)
  ) %>%
  rename(`Calidad general` = OverallQual)

cat("\nTabla de frecuencias: OverallQual\n")
print(freq_qual)


# ------------------------------------------------------------------
# BLOQUE 14 — Tabla resumen: SalePrice por OverallQual
# ------------------------------------------------------------------
tab_qual <- train %>%
  group_by(OverallQual) %>%
  summarise(
    N       = n(),
    Mínimo  = dollar(min(SalePrice)),
    Q1      = dollar(quantile(SalePrice, 0.25)),
    Mediana = dollar(median(SalePrice)),
    Media   = dollar(round(mean(SalePrice))),
    Q3      = dollar(quantile(SalePrice, 0.75)),
    Máximo  = dollar(max(SalePrice)),
    DT      = dollar(round(sd(SalePrice))),
    .groups = "drop"
  )

cat("\nEstadísticos de SalePrice por Calidad General (OverallQual):\n")
print(tab_qual)


# ------------------------------------------------------------------
# BLOQUE 15 — Matriz de correlación de Spearman
# ------------------------------------------------------------------
cor_vars <- c(
  "SalePrice", "GrLivArea", "LotArea", "LotFrontage",
  "TotalBsmtSF","GarageArea", "TotalSF", "TotalBaths",
  "HouseAge", "RemodAge", "TotRmsAbvGrd","Fireplaces",
  "WoodDeckSF", "OpenPorchSF", "OverallQual_n","QualSF"
)

train_cor <- train %>%
  mutate(OverallQual_n = as.numeric(OverallQual)) %>%
  select(all_of(cor_vars))

cor_mat <- cor(train_cor, use = "pairwise.complete.obs", method = "spearman")

par(mar = c(0, 0, 3, 0))
corrplot(
  cor_mat, method = "color", type = "upper", order = "hclust",
  tl.cex = 0.78, tl.col = "black", addCoef.col = "black", number.cex = 0.52,
  col = colorRampPalette(c("#D7191C", "white", "#2C7BB6"))(200),
  title = "Matriz de correlación de Spearman — Variables numéricas clave",
  mar = c(0, 0, 2, 0)
)

# ------------------------------------------------------------------
# BLOQUE 16 — Top 10 correlaciones de Spearman con SalePrice
# ------------------------------------------------------------------
cor_sp <- cor_mat["SalePrice", ]
top_cor <- sort(abs(cor_sp[names(cor_sp) != "SalePrice"]), decreasing = TRUE)[1:10]

p_cor <- data.frame(Variable = names(top_cor), Correlacion = as.numeric(top_cor)) %>%
  mutate(Variable = fct_reorder(Variable, Correlacion)) %>%
  ggplot(aes(x = Variable, y = Correlacion, fill = Correlacion)) +
  geom_col() +
  geom_text(aes(label = round(Correlacion, 3)), hjust = -0.1, size = 3.2) +
  scale_fill_gradient(low = "#FEE090", high = "#D7191C") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.15))) +
  coord_flip() +
  labs(
    title = "Top 10: Variables con mayor correlación con SalePrice",
    subtitle = "Valor absoluto de la correlación de Spearman",
    x = NULL, y = "|rho de Spearman|", fill = "|rho|"
  ) + theme_hp

print(p_cor)


# ==============================================================
# b.2) GRÁFICOS INTERACTIVOS (plotly)
# ==============================================================

# --- Interactivo 1: SalePrice vs TotalSF ----------------------
df_inter <- train %>%
  mutate(
    OverallQual_n = as.numeric(OverallQual),
    SP_fmt        = scales::dollar(SalePrice),
    SF_fmt        = scales::comma(TotalSF)
  )

p_interactive <- plot_ly(
  data      = df_inter,
  x         = ~TotalSF,
  y         = ~SalePrice,
  color     = ~OverallQual_n,
  colors    = viridis(10, option = "plasma"),
  type      = "scatter",
  mode      = "markers",
  marker    = list(size = 6, opacity = 0.65),
  text      = ~paste0(
    "<b>Precio de venta:</b> ",   SP_fmt,
    "<br><b>Superficie total:</b> ", SF_fmt, " sq ft",
    "<br><b>Barrio:</b> ",         Neighborhood,
    "<br><b>Calidad general:</b> ",OverallQual,
    "<br><b>Tipo de edificio:</b> ",BldgType,
    "<br><b>Estilo de la casa:</b> ",HouseStyle,
    "<br><b>Año construido:</b> ", YearBuilt,
    "<br><b>Año vendido:</b> ",    YrSold,
    "<br><b>Condición venta:</b> ",SaleCondition
  ),
  hoverinfo = "text"
) %>%
  layout(
    title = list(
      text = paste0(
        "<b>Precio de venta vs Superficie Total</b><br>",
        "<sup>Coloreado por Calidad General (1–10) — ",
        "House Prices · Ames, Iowa · Kaggle</sup>"
      ),
      font = list(size = 15)
    ),
    xaxis     = list(title = "Superficie total (sq ft)", tickformat = ","),
    yaxis     = list(title = "Precio de venta (USD)", tickprefix = "$", tickformat = ","),
    coloraxis = list(colorbar = list(title = "<b>Calidad<br>General</b>", tickvals = 1:10)),
    hovermode     = "closest",
    plot_bgcolor  = "#F8F9FA",
    paper_bgcolor = "#FFFFFF",
    font          = list(family = "Arial")
  )
print(p_interactive)


# --- Interactivo 2: SalePrice vs QualSF (feature reina) -------
df_inter_reina <- train %>%
  mutate(
    OverallQual_n = as.numeric(OverallQual),
    SP_fmt        = scales::dollar(SalePrice),
    QualSF_fmt    = scales::comma(QualSF),
    TotalSF_fmt   = scales::comma(TotalSF)
  )

p_interactive_reina <- plot_ly(
  data      = df_inter_reina,
  x         = ~QualSF,
  y         = ~SalePrice,
  color     = ~OverallQual_n,
  colors    = viridis(10, option = "plasma"),
  type      = "scatter",
  mode      = "markers",
  marker    = list(size = 6, opacity = 0.65),
  text      = ~paste0(
    "<b>Precio de venta:</b> ",       SP_fmt,
    "<br><b>QualSF (reina):</b> ",    QualSF_fmt,
    "<br><b>Superficie total:</b> ",  TotalSF_fmt, " sq ft",
    "<br><b>Barrio:</b> ",            Neighborhood,
    "<br><b>Calidad general:</b> ",   OverallQual,
    "<br><b>Tipo de edificio:</b> ",  BldgType,
    "<br><b>Estilo de la casa:</b> ", HouseStyle,
    "<br><b>Año construido:</b> ",    YearBuilt,
    "<br><b>Año vendido:</b> ",       YrSold,
    "<br><b>Condición venta:</b> ",   SaleCondition
  ),
  hoverinfo = "text"
) %>%
  layout(
    title = list(
      text = paste0(
        "<b>Precio de venta vs Feature reina (QualSF = OverallQual × TotalSF)</b><br>",
        "<sup>Coloreado por Calidad General (1–10) — House Prices · Ames, Iowa · Kaggle</sup>"
      ),
      font = list(size = 15)
    ),
    xaxis     = list(title = "QualSF (OverallQual × TotalSF)", tickformat = ","),
    yaxis     = list(title = "Precio de venta (USD)", tickprefix = "$", tickformat = ","),
    coloraxis = list(colorbar = list(title = "Calidad<br>General", tickvals = 1:10)),
    hovermode     = "closest",
    plot_bgcolor  = "#F8F9FA",
    paper_bgcolor = "#FFFFFF",
    font          = list(family = "Arial")
  )
print(p_interactive_reina)


# ==============================================================
cat("\n", strrep("=", 65), "\n")
cat("✓ Análisis completado con éxito.\n")
cat(strrep("=", 65), "\n")
